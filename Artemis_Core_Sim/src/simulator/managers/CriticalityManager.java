package simulator.managers;

import java.math.BigDecimal;
import java.util.HashMap;
import java.util.Vector;

import logger.GlobalLogger;
import logger.XmlLogger;
import modeler.WCTTModelComputer;
import root.elements.criticality.CriticalityLevel;
import root.elements.network.modules.flow.MCFlow;
import root.elements.network.modules.flow.NetworkFlow;
import root.elements.network.modules.machine.Machine;
import root.elements.network.modules.task.ISchedulable;
import root.elements.network.modules.task.NetworkMessage;
import root.util.constants.ComputationConstants;
import root.util.constants.ConfigParameters;
import utils.ConfigLogger;

public class CriticalityManager {
	/* Mixed-criticality management */
	public HashMap<Double, CriticalityLevel> critSwitches;
	
	public CriticalityLevel currentCritLvl;
	
	public CriticalityManager() {
		critSwitches = new HashMap<Double, CriticalityLevel>();
		currentCritLvl = CriticalityLevel.NONCRITICAL;
		wcttComputer = new WCTTModelComputer();
	}
	
	public CriticalityLevel getCurrentLevel() {
		return this.currentCritLvl;
	}
	
	public void setCurrentLevel(CriticalityLevel lvl) {
		this.currentCritLvl = lvl;
	}
	
	public void checkCriticalityLevel(double time) {
		if(critSwitches.get(time) != null) {
			this.currentCritLvl = critSwitches.get(time);
		}
	}
	

	/**
	 * WCTT Model Computer, to compute real transmission time according to WCTT
	 */
	private WCTTModelComputer wcttComputer;

	public WCTTModelComputer getWCTTModelComputer() {
		return wcttComputer;
	}
	
	public double getCentralizedDynamicWCTT(MCFlow newMsg, double initialWCTT, double time) {
		double wctt = 0.0;
		double currentWCTT = -1;
		CriticalityLevel destination = currentCritLvl;
		
		if(wctt != -1) {
			this.getWCTTModelComputer().currentMessage = newMsg;
			wctt = this.getWCTTModelComputer().getWcet(initialWCTT);
			this.getWCTTModelComputer().currentMessage = null;
			
			wctt = new BigDecimal(wctt).setScale(1, BigDecimal.ROUND_HALF_DOWN).doubleValue();
			
			/* If the wctt exceeds the WCTT for the current criticality level, 
			 * we check for the next level to switch to */
			for(CriticalityLevel critLvl : newMsg.getSize().keySet()) {			
				if(wctt <= newMsg.getSize().get(critLvl) && (currentWCTT > wctt || currentWCTT == -1)) {
					/* We keep the level from decreasing */
					if(wctt > newMsg.getSize().get(currentCritLvl)) {
						currentWCTT = wctt;
						destination = critLvl;
					}
				}
			}
		}
		
		if(destination != currentCritLvl) {
			// TODO : We suppose switching criticality level delay equal to 1
			critSwitches.put(time+ComputationConstants.TIMESCALE, destination);
			GlobalLogger.debug("Criticality Level switch added to "+destination+" at time "+(time+ComputationConstants.TIMESCALE));
		}
		return wctt;
	}
	
	/** 
	 * Returns the message WCTT, depending of the Mixed-criticality model
	 * @param newMsg the message, currentLvl the current criticality level
	 * @return WCTT
	 */
	public double getWCTTFromMCModel(MCFlow newMsg, CriticalityLevel currentLvl, double time) {
		double wctt = 0.0;
		
		switch(ComputationConstants.getInstance().CRITMODEL) {
			case CENTRALIZED_STATIC :
				wctt = ((MCFlow)(newMsg)).getSize(currentLvl);
				if(wctt != -1) {
					wctt = this.getWCTTModelComputer().getWcet(wctt);

					wctt = new BigDecimal(wctt).setScale(1, BigDecimal.ROUND_HALF_DOWN).doubleValue();
					((MCFlow)(newMsg)).wcetTask = wctt;
				}
				break;
			case CENTRALIZED_DYNAMIC :
				wctt = ((MCFlow)(newMsg)).getMaxWCTT();
				
				if(wctt != -1) {
					wctt = getCentralizedDynamicWCTT(newMsg, wctt, time);
					((MCFlow)(newMsg)).wcetTask = wctt;
				}
				
				break;
			case DECENTRALIZED_DYNAMIC:
				break;
			default : 
				break;
		}
		
				
		
		return wctt;
	}
	
	public int generateMessages(Machine fromMachine, double currentTime) {
		ISchedulable currentMsg;
		NetworkMessage newMsg;
		
		for(int i=0;i<fromMachine.messageGenerator.size();i++) {
			
			/* We get the message generator content. It includes all the messages
			 * which should be generated by a specified machine
			 */
			if(ConfigParameters.MIXED_CRITICALITY) {
				currentMsg = (MCFlow) fromMachine.messageGenerator.get(i);
			}
			else {
				currentMsg = (NetworkFlow) fromMachine.messageGenerator.get(i);
			}
	
			newMsg = new NetworkMessage();
	
			for(CriticalityLevel critLvl : CriticalityLevel.values()) {
				if(currentMsg.getWcet(critLvl) > 0) {
					newMsg.critLevel.add(critLvl);
				}
			}
			
			
			if(currentMsg.getNextSend() == currentTime) {
				try {	
					//We adjust the WCTT according to WCTT computation model
					double wctt = 0.0;
					
					if(ConfigParameters.MIXED_CRITICALITY) {
						wctt = this.getWCTTFromMCModel((MCFlow)currentMsg, getCurrentLevel(), currentTime);
					}
					
					currentMsg.increaseNbExec();
					currentMsg.setNextSend(currentTime);
					
					newMsg.wctt = wctt;
					newMsg.name = currentMsg.getName() + "_" + currentMsg.getNbExec();
					newMsg.networkPath = currentMsg.getNetworkPath();
					newMsg.currentNode = 1;
					newMsg.priority = currentMsg.getPriority();
					
					/* We put the copy in the input buffer of the generating node */
					fromMachine.inputBuffer.add(newMsg);
					
					if(currentMsg.getPeriod() != 0) {
						/* Periodic sending */
						currentMsg.setNextSend(currentMsg.getNextSend()+currentMsg.getPeriod());
					}
					else {
						/* Sporadic sending */
						fromMachine.messageGenerator.remove(i);
					}
				} catch (Exception e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}		
		}
		return 0;
	}
	
	/* XML Logger */
	public void generateMCSwitchesLog() {
		String name = "critswitches";
		
		XmlLogger xmlLogger = new XmlLogger(ConfigLogger.RESSOURCES_PATH+"/"+ConfigParameters.getInstance().getSimuId()+"/", name+".xml");
		xmlLogger.createDocument();
		xmlLogger.createRoot("CritSwitches");
		
		for(double time : critSwitches.keySet()) {
			xmlLogger.addChild("timer", xmlLogger.getRoot(), "value:"+time,"level:"+critSwitches.get(time));
		}
	}
}
