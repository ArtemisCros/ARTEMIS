package simulator.generation;

import logger.GlobalLogger;
import root.elements.criticality.CriticalityLevel;
import root.elements.network.modules.flow.MCFlow;
import root.elements.network.modules.machine.Machine;
import root.elements.network.modules.task.ISchedulable;
import root.elements.network.modules.task.NetworkMessage;
import root.util.constants.ConfigParameters;
import simulator.managers.CriticalityManager;
import utils.Errors;

public class MessageGenerator {
	/** 
	 * The network criticality manager
	 */
	private CriticalityManager critManager;
	
	/**
	 * 
	 */
	private WCTTManager wcttComputer;
	
	/**
	 * Message generation module
	 * Used for each input which is generating messages to send
	 * @param critManagerP Criticality manager of the network
	 */
	public MessageGenerator(CriticalityManager critManagerP) {
		this.critManager 	= critManagerP;
		this.wcttComputer 	= new WCTTManager(critManagerP);
	}
	
	/**
	 * Generate the messages from an input node
	 * @param fromMachine the input node
	 * @param currentTime the instant of generation
	 * @return error code
	 */
	public int generateMessages(Machine fromMachine, double currentTime) {
		ISchedulable currentMsg;
		NetworkMessage newMsg;
		final int size = fromMachine.messageGenerator.size();
		final int critLvlSize = CriticalityLevel.values().length;
		int cptCritLvl;
		CriticalityLevel critLvl;
		
		for(int i=0;i<size;i++) {
			
			/* We get the message generator content. It includes all the messages
			 * which should be generated by a specified machine
			 */
			currentMsg = (MCFlow) fromMachine.messageGenerator.get(i);
			newMsg = new NetworkMessage();
			
			
			for(cptCritLvl=0;cptCritLvl<critLvlSize;) {
				critLvl = CriticalityLevel.values()[cptCritLvl];
			//}
			//for(CriticalityLevel critLvl : CriticalityLevel.values()) {
				if(currentMsg.getWcet(critLvl) > 0) {
					newMsg.critLevel.add(critLvl);
				}
				cptCritLvl++;
			}		
			
			if(currentMsg.getNextSend() == currentTime) {
				try {	
					//We adjust the WCTT according to WCTT computation model
					double wctt = 0.0;
					
					wctt = wcttComputer.getWCTTFromMCModel((MCFlow)currentMsg, 
								fromMachine.getCritLevel(), currentTime, 
								fromMachine);
					
					currentMsg.increaseNbExec();
					currentMsg.setNextSend(currentTime);
					
					newMsg.wctt = wctt;
					newMsg.name = currentMsg.getName() + "_" + currentMsg.getNbExec();
					newMsg.networkPath = currentMsg.getNetworkPath();
					newMsg.currentNode = 1;
					newMsg.priority = currentMsg.getPriority();
					
					newMsg.currentCritLevel = critManager.checkMessageCritLevel((MCFlow)currentMsg, wctt);  
					
					/* We put the copy in the input buffer of the generating node */
					fromMachine.inputBuffer.add(newMsg);
					
					if(currentMsg.getPeriod() != 0) {
						/* Periodic sending */
						currentMsg.setNextSend(currentMsg.getNextSend()+currentMsg.getPeriod());
					}
					else {
						/* Sporadic sending */
						fromMachine.messageGenerator.remove(i);
					}
				} catch (Exception e) {
					GlobalLogger.error(Errors.ERROR_CREATING_MSG, "ERROR CREATING NEW MESSAGE IN CRITICALITY MANAGER");
					e.printStackTrace();
				}
				
			}
			
		}
		return 0;
	}
	
	public void generateMCSwitchesLog() {
		critManager.generateMCSwitchesLog();
	}
}
