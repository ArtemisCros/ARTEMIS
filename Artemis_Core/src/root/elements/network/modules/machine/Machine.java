package root.elements.network.modules.machine;

import java.util.ArrayList;
import java.util.Vector;

import logger.GlobalLogger;
import logger.XmlLogger;

import root.elements.network.modules.NetworkModule;
import root.elements.network.modules.link.Link;
import root.elements.network.modules.task.ISchedulable;
import root.elements.network.modules.task.MCMessage;
import root.elements.network.modules.task.NetworkMessage;
import root.util.constants.ConfigParameters;
import root.util.tools.NetworkAddress;

/**
 * @author Olivier Cros
 *  Description of a generical machine in the network
 */
public class Machine extends NetworkModule {
	/**
	 *  Address of the machine
	 */
	public NetworkAddress networkAddress;
	
	/** 
	 * Indicates the total load for the node 
	 */
	public double nodeLoad;
	
	/**
	 * List of output ports for the machine
	 */
	public Link[] portsOutput;
	
	/** 
	 * List of input ports for the machine
	 */
	public Link[] portsInput;
	
	/**
	 *  Time for analysing a packet 
	 */
	public double analyseTime;
	
	/**
	 *  Currently transmitted message
	 */
	public ISchedulable currentlyTransmittedMsg;
	
	/**
	 *  Contains all the messages generated by the machine 
	 */
	public ArrayList<ISchedulable> messageGenerator;
	
	/**
	 * The number of input/output ports
	 */
	public int portsNumber;
	
	/** get ports number
	 * 
	 */
	public int getPortsNumber() {
		return portsNumber;
	}
	public void setPortsNumber(final int pPortsNumber) {
		 this.portsNumber = pPortsNumber;
	}
	
	/**
	 *  Buffering messages in an output buffer 
	 */
	public Vector<ISchedulable> outputBuffer;
	
	/**
	 *  Buffering messages in an input buffer
	 */
	public Vector<ISchedulable> inputBuffer;
	
	/**
	 * Name of the machine
	 */
	public String name; 
	
	/**
	 * XML LOG FILE
	 */
	public String logXML;
	
	/** 
	 * XML Logger class
	 */
	public XmlLogger xmlLogger;
	
	/**
	 * Does the machine needs reload of ports ?
	 */
	public boolean needReload;
	
	/**
	 * Get current network address
 	 * @return the network address
	 */
	public NetworkAddress getNetworkAddress() {
		return this.networkAddress;
	}
	
	/**
	 * Sets current network address
	 * @param nAddr The network address
	 */
	public void setNetworkAddress(NetworkAddress nAddr) {
		this.networkAddress = nAddr;
	}
	
	public Machine(final NetworkAddress pAddr, final String pName) {
		super();
		name = pName;
		openPorts(ConfigParameters.CONST_PORT_NUMBER);
		networkAddress = pAddr;
		outputBuffer = new Vector<ISchedulable>();
		inputBuffer  = new Vector<ISchedulable>();
		messageGenerator = new ArrayList<ISchedulable>();
		analyseTime = 0;
		needReload = true;
		nodeLoad = 0.0;
	}
	
	/**
	 * Machine constructor
	 * @param pAddr network address
	 * @throws Exception
	 */
	public Machine(final NetworkAddress pAddr) {
		this(pAddr, ""+pAddr.value);
	}
	
	/**
	 * Open and create the machine network ports
	 * @param pPorts number of input/output ports to create
	 */
	public void openPorts(final int pPorts) {
		portsOutput = new Link[pPorts];
		portsInput  = new Link[pPorts];
		portsNumber = pPorts;
	}
	
	public void setAddress(final NetworkAddress pNetworkAddress) {
		/* Associate a networkAddress for current machine */
		this.networkAddress = pNetworkAddress;
	}
	
	public NetworkAddress getAddress() {
		return this.networkAddress;
	}
	
	public int connectOutput(final Link link_) {
		/* Searching for next free port */
		int i = 0;
		while(portsOutput[i] != null){i++;}
		if(portsNumber <= i) {
			GlobalLogger.warning("Can't connect machine : no free output port found");
			return 1;
		}
		
		portsOutput[i] = link_;
		
		return 0;
	}
	public int connectInput(final Link link_) {
		/* Searching for next free port */
		int i = 0;
		while(portsInput[i] != null){i++;}
		if(portsNumber <= i) {
			GlobalLogger.warning("Can't connect machine : no free input port found");
			return 1;
		}
		
		portsInput[i] = link_;
		
		return 0;
	}

	public int associateMessage(final ISchedulable msg) {
		messageGenerator.add(msg);
		
		return 0;
	}
	
	public int sendMessage(final ISchedulable msg) {
		if(GlobalLogger.DEBUG_ENABLED) {
			String debug = "PUSHING "+msg.getName()+" MACHINE "+this.name;
			GlobalLogger.debug(debug);
		}
		
		outputBuffer.add(msg);

		return 0;
	}
	
	public int generateMessage(final int currentTime) {
		for(int i=0;i<messageGenerator.size();i++) {
			
			/* We get the message generator content. It includes all the messages
			 * which should be generated by a specified machine
			 */
			ISchedulable currentMsg = messageGenerator.get(i);
			ISchedulable newMsg = null;
			
			if(currentMsg.getNextSend() == currentTime) {
				//GlobalLogger.debug("MSGGENOK:"+currentMsg.getName());
				try {
					//Make a copy for each periodic message
					if(ConfigParameters.MIXED_CRITICALITY) {
						newMsg = (((MCMessage) messageGenerator.get(i)).copy());
					}
					else {
						newMsg = (((NetworkMessage)messageGenerator.get(i)).copy());
					}
					
					newMsg.setCurrentNode(1);
					newMsg.setName(currentMsg.getName() + "_" + currentMsg.getNbExec());
					newMsg.setNextSend(currentTime);
					currentMsg.increaseNbExec();
					
					/* We put the copy in the input buffer of the generating node */
					inputBuffer.add(newMsg);
					if(currentMsg.getPeriod() != 0) {
						/* Periodic sending */
						currentMsg.setNextSend(currentMsg.getNextSend()+currentMsg.getPeriod());
					}
					else {
						/* Sporadic sending */
						messageGenerator.remove(i);
					}
				} catch (Exception e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}		
		}
		return 0;
	}
	
	
	
	/* Display infos functions */
	
	public int displayCurrentMessage() {
		if(currentlyTransmittedMsg != null) {
			GlobalLogger.log("MACHINE "+networkAddress.value+":CURRENTLY TREATING :"+currentlyTransmittedMsg.getName());			
		}
		else {
			GlobalLogger.log("MACHINE "+networkAddress.value+":NOTHING TO ANALYSE");
		}
		return 0;
	}
	
	public int displayOutputBuffer() {
		String message = "OuputBuffer de la machine "+networkAddress.value+"|";
		
		for(int cptMsgOutput = 0; cptMsgOutput < outputBuffer.size(); cptMsgOutput++) {
			ISchedulable currentMsg;
			if(ConfigParameters.MIXED_CRITICALITY) {
				 currentMsg = (MCMessage) outputBuffer.elementAt(cptMsgOutput);
			}
			else {
				 currentMsg = (NetworkMessage) outputBuffer.elementAt(cptMsgOutput);
			}
			
			message += currentMsg.getName();
		}
		message += "|";
		GlobalLogger.log(message);
		return 0;
	}
	
	public int displayInputBuffer() {
		ISchedulable currentMsg;
		String message = "InputBuffer de la machine "+networkAddress.value+"|";
		
		for(int cptMsgInput = 0; cptMsgInput < inputBuffer.size(); cptMsgInput++) {
			if(ConfigParameters.MIXED_CRITICALITY) {
				currentMsg = (MCMessage)inputBuffer.elementAt(cptMsgInput);
			}
			else {
				currentMsg = (NetworkMessage)inputBuffer.elementAt(cptMsgInput);
			}
			message += currentMsg.getName()+" ";
		}
		
		message += "|";
		GlobalLogger.log(message);
		return 0;
	}
	
	/* XML Writing functions */
	public int writeLogToFile(final int timer) {
		if(currentlyTransmittedMsg != null) {
			xmlLogger.addChild("timer", xmlLogger.getRoot(), "value:"+timer,
					"message:"+currentlyTransmittedMsg.getName());		
		}
		else {
			xmlLogger.addChild("timer", xmlLogger.getRoot(), "value:"+timer+"");
		}
		return 0;
	}
	
	public XmlLogger createXMLLog() {
		xmlLogger = new XmlLogger(this.name.trim()+".xml");
		xmlLogger.createDocument();
		xmlLogger.createRoot("machine");
		//xmlLogger.getRoot().setAttribute("id", this.networkAddress.value);
		xmlLogger.getRoot().setAttribute("name", this.name);
		
		return xmlLogger;
	}
}
